<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Quantum(Qudit) Simulator — Exact Toy + Hyperscale Summary</title>
<style>
  :root{
    --bg:#0b1020; --ink:#e8eefc; --muted:#9fb3ff; --panel:#0f1730; --card:#111b36; --line:#1c274d;
    --ok:#7ee787; --warn:#ffd166; --bad:#ff7b72;
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color:transparent}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #app{min-height:100%;display:grid;grid-template-columns:minmax(280px,360px) 1fr; gap:14px; padding:14px}
  aside{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px;display:flex;flex-direction:column;gap:10px}
  main{display:grid;grid-template-rows:auto 1fr; gap:12px}
  header, .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:12px}
  h1{font-size:16px;margin:0 0 6px 0}
  label{display:flex; align-items:center; justify-content:space-between; gap:8px; margin:6px 0}
  input[type="number"]{width:90px}
  input[type="range"]{width:170px}
  .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  button{background:#15224a;color:var(--ink);border:1px solid var(--line);padding:8px 10px;border-radius:10px;cursor:pointer}
  button:hover{filter:brightness(1.08)}
  .pill{padding:4px 8px;border-radius:999px;border:1px solid var(--line);background:#0e1735}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
  .grid{display:grid; grid-template-columns:repeat(auto-fill,minmax(160px,1fr)); gap:10px}
  canvas{width:100%; height:160px; background:#0a1330; border-radius:8px; border:1px solid var(--line)}
  .stat{display:flex; justify-content:space-between; gap:10px}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)}
  .small{font-size:12px; opacity:.85}
</style>
</head>
<body>
<div id="app">
  <aside>
    <h1>Controls</h1>
    <div class="card">
      <div class="row">
        <span class="pill">Mode</span>
        <select id="mode">
          <option value="exact">Exact / Toy (product state)</option>
          <option value="summary">Hyperscale Summary (up to 1000×1000)</option>
        </select>
      </div>
      <label>Qudits N
        <input id="N" type="number" min="1" max="1000" step="1" value="8"/>
      </label>
      <label>Levels per qudit d
        <input id="d" type="number" min="2" max="1000" step="1" value="2"/>
      </label>
      <div id="exactOnly">
        <label>Randomize single-site unitaries per step
          <input id="randSingles" type="checkbox" checked/>
        </label>
        <label>Speed (steps/sec)
          <input id="speed" type="range" min="0" max="30" value="4"/>
          <span class="mono" id="speedLbl">4</span>
        </label>
      </div>
      <div id="summaryOnly" style="display:none">
        <label>Random layers applied
          <input id="layers" type="number" min="0" max="100000" value="0"/>
        </label>
        <label>Entangling rate (0–1) — heuristic
          <input id="entRate" type="range" min="0" max="1" step="0.01" value="0.30"/>
          <span class="mono" id="entLbl">0.30</span>
        </label>
      </div>
      <div class="row">
        <button id="newBtn">New</button>
        <button id="startBtn">Start</button>
        <button id="stepBtn">Step</button>
        <button id="measureBtn">Measure</button>
      </div>
      <div class="small">
        Tip: For true entanglement in-browser, we can upgrade to an <b>MPS</b> engine with bond-dimension truncation next.
      </div>
    </div>

    <div class="card">
      <h1>Math sanity</h1>
      <div class="stat"><span>Hilbert dim \(d^N\)</span><span class="mono" id="dimOut"></span></div>
      <div class="stat"><span>Bits to index basis</span><span class="mono" id="bitsOut"></span></div>
      <div class="stat"><span>Amplitudes to store</span><span class="mono" id="ampsOut"></span></div>
      <div class="stat"><span>RAM @16B/amp (GB)</span><span class="mono" id="ramOut"></span></div>
      <div class="small">Note: dimensions finite (\(d^N\)), amplitudes are continuous ⇒ uncountably many possible states.</div>
    </div>
  </aside>

  <main>
    <header>
      <h1>Status</h1>
      <div class="grid">
        <div class="card">
          <div class="stat"><span>Mode</span><span class="mono" id="modeOut"></span></div>
          <div class="stat"><span>Step</span><span class="mono" id="stepOut">0</span></div>
          <div class="stat"><span>Measured?</span><span class="mono" id="measOut">no</span></div>
        </div>
        <div class="card">
          <div class="stat"><span>Est. avg entropy / site</span><span class="mono" id="Savg">0</span></div>
          <div class="stat"><span>Max entropy per site</span><span class="mono" id="Smax">log₂(d)</span></div>
          <div class="stat"><span>Circuit depth (summary)</span><span class="mono" id="depthOut">0</span></div>
        </div>
      </div>
    </header>

    <div class="card">
      <h1>Visualization</h1>
      <div class="small">Exact/Toy: per-site marginal probabilities for the first 16 qudits. Summary: entropy & capacity plots (heuristic).</div>
      <div class="grid" id="charts"></div>
    </div>
  </main>
</div>

<script>
/* ===========================
   Utilities (math + helpers)
   =========================== */
const clamp=(x,a,b)=>Math.min(b,Math.max(a,x));
const log10=x=>Math.log10(x);
const log2=x=>Math.log2(x);
const fmtBig=(x)=>{
  if (!isFinite(x)) return "∞";
  if (x===0) return "0";
  const e=Math.floor(Math.log10(Math.abs(x)));
  if (e>=6 || e<=-3) return (x/10**e).toFixed(3)+"e"+e;
  return x.toLocaleString(undefined,{maximumFractionDigits:3});
};
const powBig=(d,n)=>{ // return log10(d^n) & log2(d^n) to avoid overflow
  return {log10: n*Math.log10(d), log2: n*Math.log2(d)};
};
function bytesForAmplitudes(d,n,bytesPerAmp=16){
  // amps = d^n, RAM = amps*bytes
  const {log10: L10} = powBig(d,n);
  const log10Amps = L10;
  const log10Bytes = log10Amps + Math.log10(bytesPerAmp);
  const bytes = Number.isFinite(log10Bytes) ? 10**log10Bytes : Infinity;
  return bytes;
}
function humanBytes(bytes){
  if (!isFinite(bytes)) return "∞";
  const units=["B","KB","MB","GB","TB","PB","EB"];
  let i=0; let v=bytes;
  while (v>=1024 && i<units.length-1){ v/=1024; i++; }
  return v.toFixed(3)+" "+units[i];
}

/* ===========================
   Exact/Toy product-state engine
   - Each qudit i: state vector psi_i of length d
   - Global state is product ⊗ psi_i (no entanglement)
   - Single-site unitaries only (d×d)
   =========================== */
class ProductState {
  constructor(N,d){
    this.N=N; this.d=d;
    this.step=0; this.measured=false;
    this.states=Array.from({length:N}, ()=>{ // |0> by default
      let v=new Float64Array(d); v[0]=1; return v;
    });
  }
  randomSingleUnitary(){
    // Random orthonormal basis via Gram-Schmidt on Gaussian vectors ⇒ a real orthogonal matrix ~O(d)
    const d=this.d;
    let M = Array.from({length:d},()=>Float64Array.from({length:d},()=>gauss()));
    // Gram-Schmidt
    for(let i=0;i<d;i++){
      for(let k=0;k<i;k++){
        let dot=0; for(let j=0;j<d;j++) dot+=M[i][j]*M[k][j];
        for(let j=0;j<d;j++) M[i][j]-=dot*M[k][j];
      }
      let nrm=Math.hypot(...M[i]); if(nrm<1e-12){ M[i][0]+=1; nrm=Math.hypot(...M[i]); }
      for(let j=0;j<d;j++) M[i][j]/=nrm;
    }
    // Random diag phases to mimic complex Haar-ish effect (still real here, but okay for a toy)
    // (Optional) skip phases; we keep it real and fast.
    return M; // columns are basis vectors
  }
  applySingle(i,U){
    // psi' = U * psi
    const psi=this.states[i], d=this.d;
    let out=new Float64Array(d);
    for(let r=0;r<d;r++){
      let s=0;
      for(let c=0;c<d;c++) s += U[r][c]*psi[c];
      out[r]=s;
    }
    // normalize
    let nrm=Math.hypot(...out); if(nrm<1e-15){ out.fill(0); out[0]=1; } else { for(let k=0;k<d;k++) out[k]/=nrm; }
    this.states[i]=out;
  }
  stepOnce(randomSingles=true){
    if(randomSingles){
      for(let i=0;i<this.N;i++){
        const U=this.randomSingleUnitary();
        this.applySingle(i,U);
      }
    }
    this.step++;
  }
  measureAll(){
    // Collapse each qudit independently according to its marginal
    let outcomes=[];
    for(let i=0;i<this.N;i++){
      const p=this.probabilities(i);
      const r=Math.random(); let acc=0, k=0;
      for(;k<this.d;k++){ acc+=p[k]; if(r<=acc){ break; } }
      // set to basis |k>
      const v=new Float64Array(this.d); v[clamp(k,0,this.d-1)]=1;
      this.states[i]=v;
      outcomes.push(k);
    }
    this.measured=true;
    return outcomes;
  }
  probabilities(i){
    const v=this.states[i];
    const p = Float64Array.from(v, x=>x*x);
    // normalize (guard numerical drift)
    let s=0; for(let k=0;k<p.length;k++) s+=p[k];
    if(Math.abs(s-1)>1e-12 && s>0) for(let k=0;k<p.length;k++) p[k]/=s;
    return p;
  }
  avgEntropy(){
    // Shannon entropy of each site's marginal (base-2), averaged
    let S=0;
    for(let i=0;i<this.N;i++){
      const p=this.probabilities(i);
      let s=0;
      for(let k=0;k<p.length;k++){
        const pk=p[k]; if(pk>1e-15) s -= pk*log2(pk);
      }
      S+=s;
    }
    return S/this.N;
  }
}
function gauss(){ // Box-Muller
  let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}

/* ===========================
   Hyperscale Summary Model
   - No state vector; just capacity/entropy estimates
   - Tracks circuit depth, heuristic entanglement growth using Page-like scaling
   =========================== */
class SummaryModel {
  constructor(N,d){
    this.N=N; this.d=d; this.depth=0; this.measured=false;
    this.avgEntropy=0; // per-site, in bits
  }
  // One "layer": pretend it adds entanglement by some fraction of the gap to Page limit
  step(entRate=0.3){
    const Smax = Math.log2(this.d);        // max site entropy (if locally maximally mixed)
    const target = 0.99*Smax;              // near-Page limit per site for wide random circuits
    const gap = target - this.avgEntropy;  // remaining headroom
    this.avgEntropy += entRate * gap;      // approach target exponentially
    if(this.avgEntropy>Smax) this.avgEntropy=Smax;
    this.depth++;
  }
  measureAll(){
    // a projective measurement destroys entanglement: drive avg site entropy toward 0
    this.avgEntropy = 0;
    this.measured=true;
  }
}

/* ===========================
   UI / App glue
   =========================== */
const els = {
  mode: document.getElementById('mode'),
  N: document.getElementById('N'),
  d: document.getElementById('d'),
  randSingles: document.getElementById('randSingles'),
  speed: document.getElementById('speed'),
  speedLbl: document.getElementById('speedLbl'),
  layers: document.getElementById('layers'),
  entRate: document.getElementById('entRate'),
  entLbl: document.getElementById('entLbl'),
  newBtn: document.getElementById('newBtn'),
  startBtn: document.getElementById('startBtn'),
  stepBtn: document.getElementById('stepBtn'),
  measureBtn: document.getElementById('measureBtn'),
  exactOnly: document.getElementById('exactOnly'),
  summaryOnly: document.getElementById('summaryOnly'),
  charts: document.getElementById('charts'),
  modeOut: document.getElementById('modeOut'),
  stepOut: document.getElementById('stepOut'),
  measOut: document.getElementById('measOut'),
  Savg: document.getElementById('Savg'),
  Smax: document.getElementById('Smax'),
  depthOut: document.getElementById('depthOut'),
  dimOut: document.getElementById('dimOut'),
  bitsOut: document.getElementById('bitsOut'),
  ampsOut: document.getElementById('ampsOut'),
  ramOut: document.getElementById('ramOut'),
};

let engine=null; let running=false; let rafId=0; let lastTick=0; let acc=0;

function rebuild(){
  const mode=els.mode.value;
  const N=Number(els.N.value);
  const d=Number(els.d.value);
  els.exactOnly.style.display = (mode==='exact')?'block':'none';
  els.summaryOnly.style.display = (mode==='summary')?'block':'none';
  els.modeOut.textContent = mode;
  els.measOut.textContent = 'no';
  // math panel
  const dims=powBig(d,N);
  const bits = dims.log2; // bits to index basis states
  els.dimOut.textContent = `d^N = ${d}^${N}  (log10≈ ${ (dims.log10).toFixed(3) })`;
  els.bitsOut.textContent = isFinite(bits) ? bits.toFixed(1) : '∞';
  const bytes = bytesForAmplitudes(d,N,16);
  els.ampsOut.textContent = isFinite(dims.log10) ? `~10^${(dims.log10).toFixed(3)}` : '∞';
  els.ramOut.textContent = humanBytes(bytes);
  // status
  els.Smax.textContent = `log₂(d) = ${Math.log2(d).toFixed(3)}`;
  els.depthOut.textContent = (mode==='summary') ? (engine?.depth||0) : '—';
  // engine
  if(mode==='exact'){
    engine = new ProductState(N,d);
  }else{
    engine = new SummaryModel(N,d);
  }
  // charts
  drawAllCharts();
  updateStatus();
}
function updateStatus(){
  els.stepOut.textContent = (engine?.step ?? engine?.depth ?? 0);
  els.measOut.textContent = engine?.measured ? 'yes' : 'no';
  const Savg = (engine instanceof ProductState) ? engine.avgEntropy() : engine.avgEntropy;
  els.Savg.textContent = Savg.toFixed(4);
  if(els.mode.value==='summary'){ els.depthOut.textContent = engine.depth; }
}
function drawAllCharts(){
  const mode=els.mode.value;
  els.charts.innerHTML='';
  if(mode==='exact'){
    // For first min(N,16) qudits, draw marginal distributions
    const N=engine.N, d=engine.d;
    const count=Math.min(N,16);
    for(let i=0;i<count;i++){
      const wrap=document.createElement('div'); wrap.className='card';
      const title=document.createElement('div'); title.innerHTML=`<b>Qudit ${i}</b> — marginal P(k)`;
      const cv=document.createElement('canvas'); cv.width=320; cv.height=140;
      wrap.appendChild(title); wrap.appendChild(cv);
      els.charts.appendChild(wrap);
      drawBars(cv, engine.probabilities(i));
    }
  } else {
    // Summary: draw three panels — entropy trend, capacity bars, and “Page-limit” gauge
    const cv1=mkChartCard("Avg entropy / site (bits)");
    const cv2=mkChartCard("Capacity (d^N) & RAM needed (log scale)");
    const cv3=mkChartCard("Approach to Page limit (per-site)");
    els.charts.append(cv1.wrap, cv2.wrap, cv3.wrap);
    drawEntropyTrend(cv1.canvas); // simple static snapshot
    drawCapacity(cv2.canvas);
    drawPageGauge(cv3.canvas);
  }
}
function mkChartCard(title){
  const wrap=document.createElement('div'); wrap.className='card';
  const head=document.createElement('div'); head.innerHTML=`<b>${title}</b>`;
  const cv=document.createElement('canvas'); cv.width=400; cv.height=160;
  wrap.append(head,cv); return {wrap, canvas:cv};
}
function drawBars(cv, probs){
  const ctx=cv.getContext('2d');
  const W=cv.width, H=cv.height;
  ctx.clearRect(0,0,W,H);
  const m=10; const w=(W-2*m)/probs.length;
  ctx.fillStyle="#9fb3ff";
  for(let i=0;i<probs.length;i++){
    const h= (H-2*m)*probs[i];
    ctx.fillRect(m+i*w, H-m-h, w*0.9, h);
  }
  // axes
  ctx.strokeStyle="#1c274d"; ctx.strokeRect(0.5,0.5,W-1,H-1);
}
function drawEntropyTrend(cv){
  const ctx=cv.getContext('2d'); const W=cv.width, H=cv.height;
  ctx.clearRect(0,0,W,H);
  const S=engine.avgEntropy; const Smax=Math.log2(engine.d);
  // bar for current S
  ctx.fillStyle="#7ee787";
  const h=(H-20)*(S/(Smax||1)); ctx.fillRect(30,H-10-h,50,h);
  ctx.fillStyle="#e8eefc"; ctx.fillText(`S=${S.toFixed(3)} bits`, 90,H-20);
  ctx.strokeStyle="#1c274d"; ctx.strokeRect(0.5,0.5,W-1,H-1);
}
function drawCapacity(cv){
  const ctx=cv.getContext('2d'); const W=cv.width, H=cv.height;
  ctx.clearRect(0,0,W,H);
  const N=engine.N, d=engine.d;
  const {log10: L10, log2: L2} = powBig(d,N);
  // bars in log
  const bars=[
    {label:"log10(d^N)", v:L10},
    {label:"bits to index", v:L2},
  ];
  const max = Math.max(...bars.map(b=>b.v));
  const m=10; const bw=(W-2*m)/bars.length;
  for(let i=0;i<bars.length;i++){
    const frac = (max>0)? (bars[i].v/max) : 0;
    const h=(H-2*m)*frac;
    ctx.fillStyle = i? "#ffd166" : "#9fb3ff";
    ctx.fillRect(m+i*bw, H-m-h, bw*0.9, h);
    ctx.fillStyle="#e8eefc"; ctx.fillText(bars[i].label, m+i*bw+4, 16+i*0);
    ctx.fillText(bars[i].v.toFixed(3), m+i*bw+4, H-6);
  }
  ctx.strokeStyle="#1c274d"; ctx.strokeRect(0.5,0.5,W-1,H-1);
}
function drawPageGauge(cv){
  const ctx=cv.getContext('2d'); const W=cv.width, H=cv.height;
  ctx.clearRect(0,0,W,H);
  const S = (engine instanceof ProductState) ? engine.avgEntropy() : engine.avgEntropy;
  const Smax = Math.log2(engine.d);
  const pct = (Smax>0)? (S/Smax) : 0;
  const x=30, y=H/2, w=W-60, h=20;
  ctx.strokeStyle="#1c274d"; ctx.strokeRect(0.5,0.5,W-1,H-1);
  ctx.fillStyle="#0a1330"; ctx.fillRect(x,y-h/2,w,h);
  ctx.fillStyle="#7ee787"; ctx.fillRect(x,y-h/2,w*pct,h);
  ctx.fillStyle="#e8eefc"; ctx.fillText(`S/Smax = ${ (100*pct).toFixed(1) }%`, x, y-10);
}

/* ===========================
   Run loop
   =========================== */
function tick(ts){
  if(!running){ return; }
  const speed=Number(els.speed.value);
  let dt = (ts - lastTick)/1000; if(!isFinite(dt) || dt<0) dt=0;
  lastTick=ts;
  acc += dt*speed;
  const mode=els.mode.value;
  const entRate = Number(els.entRate.value);
  if(mode==='exact'){
    while(acc>=1){
      engine.stepOnce(els.randSingles.checked);
      acc-=1;
    }
  }else{
    while(acc>=1){
      engine.step(entRate);
      els.layers.value = (Number(els.layers.value)+1);
      acc-=1;
    }
  }
  drawAllCharts();
  updateStatus();
  rafId = requestAnimationFrame(tick);
}

/* ===========================
   Event wiring
   =========================== */
els.mode.addEventListener('change', rebuild);
els.N.addEventListener('change', rebuild);
els.d.addEventListener('change', rebuild);
els.speed.addEventListener('input', ()=>els.speedLbl.textContent=els.speed.value);
els.entRate.addEventListener('input', ()=>els.entLbl.textContent=Number(els.entRate.value).toFixed(2));

els.newBtn.addEventListener('click', ()=>{
  rebuild();
});
els.startBtn.addEventListener('click', ()=>{
  running = !running;
  els.startBtn.textContent = running ? 'Pause' : 'Start';
  lastTick=performance.now(); acc=0;
  if(running) rafId=requestAnimationFrame(tick); else cancelAnimationFrame(rafId);
});
els.stepBtn.addEventListener('click', ()=>{
  const mode=els.mode.value;
  if(mode==='exact'){ engine.stepOnce(els.randSingles.checked); }
  else { engine.step(Number(els.entRate.value)); els.layers.value = (Number(els.layers.value)+1); }
  drawAllCharts(); updateStatus();
});
els.measureBtn.addEventListener('click', ()=>{
  if(els.mode.value==='exact'){ engine.measureAll(); }
  else { engine.measureAll(); }
  drawAllCharts(); updateStatus();
});

// init
rebuild();
</script>
</body>
</html>
